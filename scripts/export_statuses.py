#!/usr/bin/env python3
"""Export shared job status vocabulary for the frontend."""

from __future__ import annotations

import argparse
import sys
from pathlib import Path
from textwrap import indent

REPO_ROOT = Path(__file__).resolve().parents[1]
if str(REPO_ROOT) not in sys.path:
    sys.path.insert(0, str(REPO_ROOT))

from backend.services.generation.statuses import (  # noqa: E402
    DEFAULT_NORMALIZED_STATUS,
    STATUS_NORMALIZATION_MAP,
    NormalizedGenerationStatus,
)

GENERATED_TS_PATH = (
    REPO_ROOT
    / "app"
    / "frontend"
    / "src"
    / "constants"
    / "generated"
    / "jobStatuses.ts"
)

HEADER = (
    "// This file is auto-generated by scripts/export_statuses.py. "
    "Do not edit manually."
)


def _format_status_array() -> str:
    """Return a TypeScript array declaration for normalized statuses."""
    statuses = ", ".join(f"'{status.value}'" for status in NormalizedGenerationStatus)
    return f"export const NORMALIZED_JOB_STATUSES = [{statuses}] as const;"


def _format_default_status() -> str:
    """Return the default normalized job status declaration."""
    value = DEFAULT_NORMALIZED_STATUS.value
    return "\n".join(
        [
            (
                "export type GeneratedNormalizedJobStatus = "
                "(typeof NORMALIZED_JOB_STATUSES)[number];"
            ),
            (
                "export const DEFAULT_NORMALIZED_JOB_STATUS: "
                f"GeneratedNormalizedJobStatus = '{value}';"
            ),
        ],
    )


def _format_normalization_map() -> str:
    """Return a TypeScript map aligning raw statuses with normalized values."""
    items = []
    for key in sorted(STATUS_NORMALIZATION_MAP):
        items.append(f"'{key}': '{STATUS_NORMALIZATION_MAP[key].value}',")

    map_body = "{\n" + indent("\n".join(items), "  ") + "\n}"
    return (
        "export const JOB_STATUS_NORMALIZATION_MAP = "
        f"{map_body} as const satisfies Record<string, GeneratedNormalizedJobStatus>;"
    )


def build_typescript() -> str:
    """Construct the generated TypeScript module content."""
    parts = [
        HEADER,
        _format_status_array(),
        _format_default_status(),
        _format_normalization_map(),
    ]
    return "\n\n".join(parts) + "\n"


def write_typescript(path: Path) -> None:
    """Write the generated TypeScript content to ``path``."""
    path.parent.mkdir(parents=True, exist_ok=True)
    content = build_typescript()
    path.write_text(content, encoding="utf-8")


def parse_args() -> argparse.Namespace:
    """Parse command-line arguments for the exporter script."""
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--output",
        type=Path,
        default=GENERATED_TS_PATH,
        help="Destination file path for the generated TypeScript module.",
    )
    return parser.parse_args()


def main() -> None:
    """Generate the TypeScript status module using CLI arguments."""
    args = parse_args()
    write_typescript(args.output)


if __name__ == "__main__":
    main()
